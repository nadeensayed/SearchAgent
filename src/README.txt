•** General Idea of the problem:**

Our problem mainly consists of a 2d grid of cells. A cell can either contain a ship or a station or it can be empty. Each ship contains a number of passengers and once all passengers are either dead or picked up by our agent, the ship becomes a wreck and the black box becomes retrievable and the agent can now retrieve it. The agent is supposed to use different search algorithms to navigate through the grid picking up people and dropping them at a station and retrieving black boxes. The agent should save as many people as possible and retrieve as many black boxes as possible.

•** Our Hierarchy:**

In our implementation we created a class for the state that keeps track of the details of the state our agent is in including: its position in the grid, the path cost to reach this state, passengers carried, passengers left to pick up, passengers saved, black boxes left to retrieve and black boxes taken. We also save the state of our grid at that time instance inside our state class.
For the search tree node we created a class that consists of the state, the depth of the node, the parent node, and the action our agent took from the parent node to reach this state. This class contains a method called getPathFromRoot that returns a list of all ancestor nodes of this node. We also created a method calles plan that uses the getPathFromRoot method to formulate the path string of this node.
Our general search problem class contains the size of the grid, the max capacity of the agent and the initial state. This class contains the isGoal method that checks whether a state is a goal state. It also contains two other methods, the first one takes a state and returns an array of all the possible actions the agent can take from its state. The second method takes a state and an action and returns the next state. 
The coast guard class inherits from the general search problem. This is the class that contains a method that creates a grid and a search problem and solves it depending on the strategy we want. 
For the solving part we created a helper class called searchProcedure. We have two attributes in this class. The first one is a queue data structure which will either be a linked list or a priority queue depending on the search algorithm we are perfoming. The second attribute is an array list called previous that keeps track of all previous states the agent has been in so that we can avoid expanding repeated states. The class contains the expand method that expands our search nodes depending on the search strategy. We created an expand method that takes a node and a search problem and returns all the children of the node after expansion. We created a method for each search algorithm. The first step in all the strategies is that we enqueue the parent node and then we loop until a goal state is reached or the queue is empty. For the BFS, a linked list is used for the queue and as the goal stated is not yet reached, we remove the first node from the queue. As for the DFS, the same data structure is used and the only difference is that we remove the last node that has been added to the queue. For the ID, the same concept of DFS has been used with a helper method that keeps track of the depth and increments it at every iteration as long as the goal state is not yet reached. For the greedy and a* algorithms, we used a priority queue as a data structure
